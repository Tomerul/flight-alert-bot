export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    const origin = request.headers.get("Origin") || "";

    // ---------- CORS ----------
    if (request.method === "OPTIONS") {
      const headers = {
        "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, x-app-key",
        "Access-Control-Max-Age": "86400",
      };
      if (env.ALLOWED_ORIGIN) {
        if (origin && origin === env.ALLOWED_ORIGIN) {
          headers["Access-Control-Allow-Origin"] = env.ALLOWED_ORIGIN;
        } else {
          return new Response("Forbidden origin", { status: 403 });
        }
      } else {
        headers["Access-Control-Allow-Origin"] = "*";
      }
      return new Response(null, { status: 204, headers });
    }

    const cors = (headers = {}) => {
      const h = { "Content-Type": "application/json", ...headers };
      if (env.ALLOWED_ORIGIN && origin === env.ALLOWED_ORIGIN) {
        h["Access-Control-Allow-Origin"] = env.ALLOWED_ORIGIN;
      }
      return h;
    };

    // ---------- אימות בסיסי לכל קריאה שאינה OPTIONS ----------
    const clientKey = request.headers.get("x-app-key");
    if (!clientKey || clientKey !== env.APP_SHARED_KEY) {
      return new Response(JSON.stringify({ ok: false, error: "Unauthorized" }), { status: 401, headers: cors() });
    }
    if (env.ALLOWED_ORIGIN && origin && origin !== env.ALLOWED_ORIGIN) {
      return new Response(JSON.stringify({ ok: false, error: "Forbidden origin" }), { status: 403, headers: cors() });
    }

    // ---------- POST / (dispatch) ----------
    if (request.method === "POST" && url.pathname === "/") {
      let payload = {};
      try { payload = await request.json(); } catch { return new Response(JSON.stringify({ ok:false, error:"Bad JSON" }), { status:400, headers: cors() }); }
      const { owner, repo, inputs, ref } = payload || {};
      if (!owner || !repo || !inputs) {
        return new Response(JSON.stringify({ ok:false, error:"Bad Request (owner/repo/inputs required)" }), { status:400, headers: cors() });
      }
      const branchRef = (typeof ref === "string" && ref.trim()) ? ref.trim() : "main";
      const ghUrl = `https://api.github.com/repos/${owner}/${repo}/actions/workflows/config-dispatch.yml/dispatches`;
      const body = { ref: branchRef, inputs };

      const gh = await fetch(ghUrl, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${env.GH_TOKEN}`,
          "Accept": "application/vnd.github+json",
          "Content-Type": "application/json",
          "User-Agent": "flight-alert-worker"
        },
        body: JSON.stringify(body)
      });

      if (!gh.ok) {
        const text = await gh.text();
        return new Response(JSON.stringify({ ok:false, error:`GitHub ${gh.status} ${text}` }), { status: 500, headers: cors() });
      }
      return new Response(JSON.stringify({ ok: true }), { status: 200, headers: cors() });
    }

    // ---------- GET /status?owner=&repo=&workflow=config-dispatch.yml&branch=main&since=TIMESTAMP ----------
    if (request.method === "GET" && url.pathname === "/status") {
      const owner = url.searchParams.get("owner");
      const repo = url.searchParams.get("repo");
      const workflow = url.searchParams.get("workflow") || "config-dispatch.yml";
      const branch = url.searchParams.get("branch") || "main";
      const sinceMs = Number(url.searchParams.get("since") || 0);
      // מרווח ביטחון של דקה אחורה
      const sinceIso = sinceMs > 0 ? new Date(sinceMs - 60_000).toISOString() : null;

      if (!owner || !repo) {
        return new Response(JSON.stringify({ ok:false, error:"owner/repo required" }), { status:400, headers: cors() });
      }

      // ניקח עד 10 הרצות אחרונות ונאתר את זו שנוצרה אחרי ה-since
      const ghUrl = `https://api.github.com/repos/${owner}/${repo}/actions/workflows/${encodeURIComponent(workflow)}/runs?per_page=10&branch=${encodeURIComponent(branch)}`;
      const gh = await fetch(ghUrl, {
        headers: {
          "Authorization": `Bearer ${env.GH_TOKEN}`,
          "Accept": "application/vnd.github+json",
          "User-Agent": "flight-alert-worker"
        }
      });
      if (!gh.ok) {
        const text = await gh.text();
        return new Response(JSON.stringify({ ok:false, error:`GitHub ${gh.status} ${text}` }), { status: 500, headers: cors() });
      }
      const data = await gh.json();
      let run = null;
      if (Array.isArray(data.workflow_runs)) {
        if (sinceIso) {
          run = data.workflow_runs.find(r => r && r.created_at && r.created_at >= sinceIso) || null;
        }
        if (!run) run = data.workflow_runs[0] || null; // fallback לחדשה ביותר
      }

      return new Response(JSON.stringify({
        ok: true,
        run: run ? {
          id: run.id,
          status: run.status,           // queued | in_progress | completed
          conclusion: run.conclusion,   // success | failure | cancelled | null
          html_url: run.html_url,
          created_at: run.created_at,
          updated_at: run.updated_at
        } : null
      }), { status: 200, headers: cors() });
    }

    return new Response(JSON.stringify({ ok:false, error:"Not found" }), { status: 404, headers: cors() });
  }
};
